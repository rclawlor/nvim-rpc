use rmpv::Value;

use crate::api::*;
use crate::error::Error;
use crate::value_vec;

/// The below implementations are autogenerated using the Neovim API
impl Window {
    /// Since: 6
    pub fn set_config(&mut self, config: Vec<(Value, Value)>) -> Result<(), Error> {
        let mut session = self.session.lock().unwrap();
        session.call("nvim_win_set_config", value_vec!(self.data, config))?;
        Ok(())
    }

    /// Since: 6
    pub fn get_config(&mut self) -> Result<Vec<(Value, Value)>, Error> {
        let mut session = self.session.lock().unwrap();
        let ret = session.call("nvim_win_get_config", value_vec!(self.data))?;
        Ok(ret
            .as_array()
            .unwrap()
            .iter()
            .map(|x| {
                let v = x.as_array().unwrap();
                (v[0].to_owned(), v[1].to_owned())
            })
            .collect())
    }

    /// Since: 1
    pub fn get_buf(&mut self) -> Result<Buffer, Error> {
        let mut session = self.session.lock().unwrap();
        let ret = session.call("nvim_win_get_buf", value_vec!(self.data))?;
        Ok(Buffer {
            data: ret.clone(),
            session: self.session.clone(),
        })
    }

    /// Since: 5
    pub fn set_buf(&mut self, buffer: Buffer) -> Result<(), Error> {
        let mut session = self.session.lock().unwrap();
        session.call("nvim_win_set_buf", value_vec!(self.data, buffer))?;
        Ok(())
    }

    /// Since: 1
    pub fn get_cursor(&mut self) -> Result<(i64, i64), Error> {
        let mut session = self.session.lock().unwrap();
        let ret = session.call("nvim_win_get_cursor", value_vec!(self.data))?;
        let v = ret.as_array().unwrap();
        Ok((v[0].as_i64().unwrap(), v[1].as_i64().unwrap()))
    }

    /// Since: 1
    pub fn set_cursor(&mut self, pos: (i64, i64)) -> Result<(), Error> {
        let mut session = self.session.lock().unwrap();
        session.call("nvim_win_set_cursor", value_vec!(self.data, pos))?;
        Ok(())
    }

    /// Since: 1
    pub fn get_height(&mut self) -> Result<i64, Error> {
        let mut session = self.session.lock().unwrap();
        let ret = session.call("nvim_win_get_height", value_vec!(self.data))?;
        Ok(ret.as_i64().unwrap())
    }

    /// Since: 1
    pub fn set_height(&mut self, height: i64) -> Result<(), Error> {
        let mut session = self.session.lock().unwrap();
        session.call("nvim_win_set_height", value_vec!(self.data, height))?;
        Ok(())
    }

    /// Since: 1
    pub fn get_width(&mut self) -> Result<i64, Error> {
        let mut session = self.session.lock().unwrap();
        let ret = session.call("nvim_win_get_width", value_vec!(self.data))?;
        Ok(ret.as_i64().unwrap())
    }

    /// Since: 1
    pub fn set_width(&mut self, width: i64) -> Result<(), Error> {
        let mut session = self.session.lock().unwrap();
        session.call("nvim_win_set_width", value_vec!(self.data, width))?;
        Ok(())
    }

    /// Since: 1
    pub fn get_var(&mut self, name: String) -> Result<Value, Error> {
        let mut session = self.session.lock().unwrap();
        let ret = session.call("nvim_win_get_var", value_vec!(self.data, name))?;
        Ok(ret.to_owned())
    }

    /// Since: 1
    pub fn set_var(&mut self, name: String, value: Value) -> Result<(), Error> {
        let mut session = self.session.lock().unwrap();
        session.call("nvim_win_set_var", value_vec!(self.data, name, value))?;
        Ok(())
    }

    /// Since: 1
    pub fn del_var(&mut self, name: String) -> Result<(), Error> {
        let mut session = self.session.lock().unwrap();
        session.call("nvim_win_del_var", value_vec!(self.data, name))?;
        Ok(())
    }

    /// Since: 1
    pub fn get_position(&mut self) -> Result<(i64, i64), Error> {
        let mut session = self.session.lock().unwrap();
        let ret = session.call("nvim_win_get_position", value_vec!(self.data))?;
        let v = ret.as_array().unwrap();
        Ok((v[0].as_i64().unwrap(), v[1].as_i64().unwrap()))
    }

    /// Since: 1
    pub fn get_tabpage(&mut self) -> Result<Tabpage, Error> {
        let mut session = self.session.lock().unwrap();
        let ret = session.call("nvim_win_get_tabpage", value_vec!(self.data))?;
        Ok(Tabpage {
            data: ret.clone(),
            session: self.session.clone(),
        })
    }

    /// Since: 1
    pub fn get_number(&mut self) -> Result<i64, Error> {
        let mut session = self.session.lock().unwrap();
        let ret = session.call("nvim_win_get_number", value_vec!(self.data))?;
        Ok(ret.as_i64().unwrap())
    }

    /// Since: 1
    pub fn is_valid(&mut self) -> Result<bool, Error> {
        let mut session = self.session.lock().unwrap();
        let ret = session.call("nvim_win_is_valid", value_vec!(self.data))?;
        Ok(ret.as_bool().unwrap())
    }

    /// Since: 7
    pub fn hide(&mut self) -> Result<(), Error> {
        let mut session = self.session.lock().unwrap();
        session.call("nvim_win_hide", value_vec!(self.data))?;
        Ok(())
    }

    /// Since: 6
    pub fn close(&mut self, force: bool) -> Result<(), Error> {
        let mut session = self.session.lock().unwrap();
        session.call("nvim_win_close", value_vec!(self.data, force))?;
        Ok(())
    }

    /// Since: 7
    pub fn call(&mut self, fun: Value) -> Result<Value, Error> {
        let mut session = self.session.lock().unwrap();
        let ret = session.call("nvim_win_call", value_vec!(self.data, fun))?;
        Ok(ret.to_owned())
    }

    /// Since: 10
    pub fn set_hl_ns(&mut self, ns_id: i64) -> Result<(), Error> {
        let mut session = self.session.lock().unwrap();
        session.call("nvim_win_set_hl_ns", value_vec!(self.data, ns_id))?;
        Ok(())
    }

    /// Since: 12
    pub fn text_height(&mut self, opts: Vec<(Value, Value)>) -> Result<Vec<(Value, Value)>, Error> {
        let mut session = self.session.lock().unwrap();
        let ret = session.call("nvim_win_text_height", value_vec!(self.data, opts))?;
        Ok(ret
            .as_array()
            .unwrap()
            .iter()
            .map(|x| {
                let v = x.as_array().unwrap();
                (v[0].to_owned(), v[1].to_owned())
            })
            .collect())
    }
}
